"use strict";var _store=require("svelte/store");Object.defineProperty(exports,"__esModule",{value:!0}),exports.createStore=void 0;let store;const throwError=a=>{throw new Error(`[svelte-createstore error] : ${a}`)},isObject=a=>a===Object(a),isDate=a=>"Invalid Date"!==new Date(a).toString()&&!isNaN(new Date(a)),getState=(a=null)=>{let b;return store.subscribe(a=>b=a)(),b},getSchema=(a,b={})=>{for(var c in a){var d=a[c],e=typeof d;"undefined"===e&&(e="null"),"string"===e&&isDate(d)&&(e="date"),"object"===e?(b[c]=getSchema(a[c]),b[c].type=e):b[c]={type:e}}return b},setLoading=a=>{getState(a).loading||store.update(a=>deepMerge(a,{loading:!0,error:null}))},setError=(a,b)=>{getState(b).error!==a&&store.update(b=>deepMerge(b,{error:a,loading:!1}))},deepMerge=(a,b)=>isObject(a)&&isObject(b)?(Object.keys(b).forEach(c=>{const d=a[c],e=b[c];a[c]=Array.isArray(d)&&Array.isArray(e)?d.concat(e):isObject(d)&&isObject(e)?deepMerge(Object.assign({},d),e):e}),a):b,isDeepEqual=(c,a)=>{let b=a=>Object.entries(a).sort().map(a=>(a[1]instanceof Object&&(a[1]=b(a[1])),a));return JSON.stringify(b(c))===JSON.stringify(b(a))},setSuccess=(a,b)=>{store.update(c=>deepMerge(c,b?{state:{[b]:a},loading:!1,error:null}:{state:{...a},loading:!1,error:null}))},mountInitialState=(a,b)=>{let c=a;return Object.keys(b||{}).forEach(a=>{b[a].initialState||throwError(`initialState of module ${a} must be of type Object`),c[a]={...b[a].initialState}}),c},mountActions=(a,b,c=null)=>deepMerge(Object.keys(a).reduce((b,d)=>({...b,...{[d]:(...b)=>executeAction(a[d],c,...b)}}),{}),Object.keys(b||{}).reduce((a,c)=>deepMerge({...a},{[c]:mountActions(b[c].actions,{},c)||{}}),{})),executeAction=async(a,b=null,...c)=>{try{let d=getState().state;b&&(d=d[b]);let e;const f=a(d,...c);f instanceof Promise?(setLoading(b),e=await Promise.resolve(f)):e=f,isDeepEqual(getSchema(deepMerge(d,e)),getSchema(d))||throwError(`action '${a}'${b?" of module "+b+" ":""} returned schema [ ${JSON.stringify(getSchema(e))} ] differs from current state schema [ ${JSON.stringify(getSchema(d))} ] `),setSuccess(e,b)}catch(a){setError(a,b)}},createStore=({initialState:a=null,actions:b=null,modules:c=null})=>{isObject(a)||throwError("initialState must be of type Object"),b||throwError("no actions provided"),isObject(b)||throwError("actions must be of type Object"),store=(0,_store.writable)({state:mountInitialState(a,c),loading:!1,error:null});const d=mountActions(b,c);return{subscribe:store.subscribe,...d}};exports.createStore=createStore;